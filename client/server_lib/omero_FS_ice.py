# **********************************************************************
#
# Copyright (c) 2003-2011 ZeroC, Inc. All rights reserved.
#
# This copy of Ice is licensed to you under the terms described in the
# ICE_LICENSE file included in this distribution.
#
# **********************************************************************
#
# Ice version 3.4.2
#
# <auto-generated>
#
# Generated from file `FS.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>
#

import Ice, IcePy, __builtin__
import Ice_BuiltinSequences_ice
import omero_ServerErrors_ice

# Included module Ice
_M_Ice = Ice.openModule('Ice')

# Included module Glacier2
_M_Glacier2 = Ice.openModule('Glacier2')

# Included module omero
_M_omero = Ice.openModule('omero')

# Start of module omero
__name__ = 'omero'

# Start of module omero.grid
_M_omero.grid = Ice.openModule('omero.grid')
__name__ = 'omero.grid'

# Start of module omero.grid.monitors
_M_omero.grid.monitors = Ice.openModule('omero.grid.monitors')
__name__ = 'omero.grid.monitors'

if not _M_omero.grid.monitors.__dict__.has_key('EventType'):
    _M_omero.grid.monitors.EventType = Ice.createTempClass()
    class EventType(object):
        '''Enumeration for Monitor event types returned.

Create, event is file or directory creation.
Modify, event is file or directory modification.
Delete, event is file or directory deletion.
System, used to flag a system notification, info in fileId.'''

        def __init__(self, val):
            assert(val >= 0 and val < 4)
            self.value = val

        def __str__(self):
            return self._names[self.value]

        __repr__ = __str__

        def __hash__(self):
            return self.value

        def __lt__(self, other):
            if isinstance(other, _M_omero.grid.monitors.EventType):
                return self.value < other.value;
            elif other == None:
                return False
            return NotImplemented

        def __le__(self, other):
            if isinstance(other, _M_omero.grid.monitors.EventType):
                return self.value <= other.value;
            elif other == None:
                return False
            return NotImplemented

        def __eq__(self, other):
            if isinstance(other, _M_omero.grid.monitors.EventType):
                return self.value == other.value;
            elif other == None:
                return False
            return NotImplemented

        def __ne__(self, other):
            if isinstance(other, _M_omero.grid.monitors.EventType):
                return self.value != other.value;
            elif other == None:
                return False
            return NotImplemented

        def __gt__(self, other):
            if isinstance(other, _M_omero.grid.monitors.EventType):
                return self.value > other.value;
            elif other == None:
                return False
            return NotImplemented

        def __ge__(self, other):
            if isinstance(other, _M_omero.grid.monitors.EventType):
                return self.value >= other.value;
            elif other == None:
                return False
            return NotImplemented

        _names = ('Create', 'Modify', 'Delete', 'System')

    EventType.Create = EventType(0)
    EventType.Modify = EventType(1)
    EventType.Delete = EventType(2)
    EventType.System = EventType(3)

    _M_omero.grid.monitors._t_EventType = IcePy.defineEnum('::omero::grid::monitors::EventType', EventType, (), (EventType.Create, EventType.Modify, EventType.Delete, EventType.System))

    _M_omero.grid.monitors.EventType = EventType
    del EventType

if not _M_omero.grid.monitors.__dict__.has_key('EventInfo'):
    _M_omero.grid.monitors.EventInfo = Ice.createTempClass()
    class EventInfo(object):
        '''The id and type of an event. The file's basename is included for convenience,
other stats are not included since they may be unavailable for some event types.'''
        def __init__(self, fileId='', type=_M_omero.grid.monitors.EventType.Create):
            self.fileId = fileId
            self.type = type

        def __hash__(self):
            _h = 0
            _h = 5 * _h + __builtin__.hash(self.fileId)
            _h = 5 * _h + __builtin__.hash(self.type)
            return _h % 0x7fffffff

        def __lt__(self, other):
            if isinstance(other, _M_omero.grid.monitors.EventInfo):
                return self.fileId < other.fileId or self.type < other.type
            elif other == None:
                return False
            return NotImplemented

        def __le__(self, other):
            if isinstance(other, _M_omero.grid.monitors.EventInfo):
                return self.fileId <= other.fileId or self.type <= other.type
            elif other == None:
                return False
            return NotImplemented

        def __eq__(self, other):
            if isinstance(other, _M_omero.grid.monitors.EventInfo):
                return self.fileId == other.fileId and self.type == other.type
            elif other == None:
                return False
            return NotImplemented

        def __ne__(self, other):
            if isinstance(other, _M_omero.grid.monitors.EventInfo):
                return self.fileId != other.fileId or self.type != other.type
            elif other == None:
                return True
            return NotImplemented

        def __gt__(self, other):
            if isinstance(other, _M_omero.grid.monitors.EventInfo):
                return self.fileId > other.fileId or self.type > other.type
            elif other == None:
                return False
            return NotImplemented

        def __ge__(self, other):
            if isinstance(other, _M_omero.grid.monitors.EventInfo):
                return self.fileId >= other.fileId or self.type >= other.type
            elif other == None:
                return False
            return NotImplemented

        def __str__(self):
            return IcePy.stringify(self, _M_omero.grid.monitors._t_EventInfo)

        __repr__ = __str__

    _M_omero.grid.monitors._t_EventInfo = IcePy.defineStruct('::omero::grid::monitors::EventInfo', EventInfo, (), (
        ('fileId', (), IcePy._t_string),
        ('type', (), _M_omero.grid.monitors._t_EventType)
    ))

    _M_omero.grid.monitors.EventInfo = EventInfo
    del EventInfo

if not _M_omero.grid.monitors.__dict__.has_key('_t_EventList'):
    _M_omero.grid.monitors._t_EventList = IcePy.defineSequence('::omero::grid::monitors::EventList', (), _M_omero.grid.monitors._t_EventInfo)

if not _M_omero.grid.monitors.__dict__.has_key('MonitorClient'):
    _M_omero.grid.monitors.MonitorClient = Ice.createTempClass()
    class MonitorClient(Ice.Object):
        '''This interface must be implemented by a client that
wishes to subscribe to an OMERO.fs server.'''
        def __init__(self):
            if __builtin__.type(self) == _M_omero.grid.monitors.MonitorClient:
                raise RuntimeError('omero.grid.monitors.MonitorClient is an abstract class')

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::omero::grid::monitors::MonitorClient')

        def ice_id(self, current=None):
            return '::omero::grid::monitors::MonitorClient'

        def ice_staticId():
            return '::omero::grid::monitors::MonitorClient'
        ice_staticId = staticmethod(ice_staticId)

        def fsEventHappened(self, id, el, current=None):
            '''Callback, called by the monitor upon the proxy of the OMERO.fs client.

Arguments:
    id, monitor Id from which the event was reported (string).
    el, list of events (EventList).
Returns:
     no explicit return value.'''
            pass

        def __str__(self):
            return IcePy.stringify(self, _M_omero.grid.monitors._t_MonitorClient)

        __repr__ = __str__

    _M_omero.grid.monitors.MonitorClientPrx = Ice.createTempClass()
    class MonitorClientPrx(Ice.ObjectPrx):

        '''Callback, called by the monitor upon the proxy of the OMERO.fs client.

Arguments:
    id, monitor Id from which the event was reported (string).
    el, list of events (EventList).
Returns:
     no explicit return value.'''
        def fsEventHappened(self, id, el, _ctx=None):
            return _M_omero.grid.monitors.MonitorClient._op_fsEventHappened.invoke(self, ((id, el), _ctx))

        '''Callback, called by the monitor upon the proxy of the OMERO.fs client.

Arguments:
    id, monitor Id from which the event was reported (string).
    el, list of events (EventList).
Returns:
     no explicit return value.'''
        def begin_fsEventHappened(self, id, el, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_omero.grid.monitors.MonitorClient._op_fsEventHappened.begin(self, ((id, el), _response, _ex, _sent, _ctx))

        '''Callback, called by the monitor upon the proxy of the OMERO.fs client.

Arguments:
    id, monitor Id from which the event was reported (string).
    el, list of events (EventList).
Returns:
     no explicit return value.'''
        def end_fsEventHappened(self, _r):
            return _M_omero.grid.monitors.MonitorClient._op_fsEventHappened.end(self, _r)

        def checkedCast(proxy, facetOrCtx=None, _ctx=None):
            return _M_omero.grid.monitors.MonitorClientPrx.ice_checkedCast(proxy, '::omero::grid::monitors::MonitorClient', facetOrCtx, _ctx)
        checkedCast = staticmethod(checkedCast)

        def uncheckedCast(proxy, facet=None):
            return _M_omero.grid.monitors.MonitorClientPrx.ice_uncheckedCast(proxy, facet)
        uncheckedCast = staticmethod(uncheckedCast)

    _M_omero.grid.monitors._t_MonitorClientPrx = IcePy.defineProxy('::omero::grid::monitors::MonitorClient', MonitorClientPrx)

    _M_omero.grid.monitors._t_MonitorClient = IcePy.defineClass('::omero::grid::monitors::MonitorClient', MonitorClient, (), True, None, (), ())
    MonitorClient._ice_type = _M_omero.grid.monitors._t_MonitorClient

    MonitorClient._op_fsEventHappened = IcePy.Operation('fsEventHappened', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, (), (((), IcePy._t_string), ((), _M_omero.grid.monitors._t_EventList)), (), None, (_M_omero._t_ServerError,))

    _M_omero.grid.monitors.MonitorClient = MonitorClient
    del MonitorClient

    _M_omero.grid.monitors.MonitorClientPrx = MonitorClientPrx
    del MonitorClientPrx

if not _M_omero.grid.monitors.__dict__.has_key('MonitorType'):
    _M_omero.grid.monitors.MonitorType = Ice.createTempClass()
    class MonitorType(object):

        def __init__(self, val):
            assert(val >= 0 and val < 3)
            self.value = val

        def __str__(self):
            return self._names[self.value]

        __repr__ = __str__

        def __hash__(self):
            return self.value

        def __lt__(self, other):
            if isinstance(other, _M_omero.grid.monitors.MonitorType):
                return self.value < other.value;
            elif other == None:
                return False
            return NotImplemented

        def __le__(self, other):
            if isinstance(other, _M_omero.grid.monitors.MonitorType):
                return self.value <= other.value;
            elif other == None:
                return False
            return NotImplemented

        def __eq__(self, other):
            if isinstance(other, _M_omero.grid.monitors.MonitorType):
                return self.value == other.value;
            elif other == None:
                return False
            return NotImplemented

        def __ne__(self, other):
            if isinstance(other, _M_omero.grid.monitors.MonitorType):
                return self.value != other.value;
            elif other == None:
                return False
            return NotImplemented

        def __gt__(self, other):
            if isinstance(other, _M_omero.grid.monitors.MonitorType):
                return self.value > other.value;
            elif other == None:
                return False
            return NotImplemented

        def __ge__(self, other):
            if isinstance(other, _M_omero.grid.monitors.MonitorType):
                return self.value >= other.value;
            elif other == None:
                return False
            return NotImplemented

        _names = ('Persistent', 'OneShot', 'Inactivity')

    MonitorType.Persistent = MonitorType(0)
    MonitorType.OneShot = MonitorType(1)
    MonitorType.Inactivity = MonitorType(2)

    _M_omero.grid.monitors._t_MonitorType = IcePy.defineEnum('::omero::grid::monitors::MonitorType', MonitorType, (), (MonitorType.Persistent, MonitorType.OneShot, MonitorType.Inactivity))

    _M_omero.grid.monitors.MonitorType = MonitorType
    del MonitorType

if not _M_omero.grid.monitors.__dict__.has_key('FileType'):
    _M_omero.grid.monitors.FileType = Ice.createTempClass()
    class FileType(object):

        def __init__(self, val):
            assert(val >= 0 and val < 5)
            self.value = val

        def __str__(self):
            return self._names[self.value]

        __repr__ = __str__

        def __hash__(self):
            return self.value

        def __lt__(self, other):
            if isinstance(other, _M_omero.grid.monitors.FileType):
                return self.value < other.value;
            elif other == None:
                return False
            return NotImplemented

        def __le__(self, other):
            if isinstance(other, _M_omero.grid.monitors.FileType):
                return self.value <= other.value;
            elif other == None:
                return False
            return NotImplemented

        def __eq__(self, other):
            if isinstance(other, _M_omero.grid.monitors.FileType):
                return self.value == other.value;
            elif other == None:
                return False
            return NotImplemented

        def __ne__(self, other):
            if isinstance(other, _M_omero.grid.monitors.FileType):
                return self.value != other.value;
            elif other == None:
                return False
            return NotImplemented

        def __gt__(self, other):
            if isinstance(other, _M_omero.grid.monitors.FileType):
                return self.value > other.value;
            elif other == None:
                return False
            return NotImplemented

        def __ge__(self, other):
            if isinstance(other, _M_omero.grid.monitors.FileType):
                return self.value >= other.value;
            elif other == None:
                return False
            return NotImplemented

        _names = ('File', 'Dir', 'Link', 'Mount', 'Unknown')

    FileType.File = FileType(0)
    FileType.Dir = FileType(1)
    FileType.Link = FileType(2)
    FileType.Mount = FileType(3)
    FileType.Unknown = FileType(4)

    _M_omero.grid.monitors._t_FileType = IcePy.defineEnum('::omero::grid::monitors::FileType', FileType, (), (FileType.File, FileType.Dir, FileType.Link, FileType.Mount, FileType.Unknown))

    _M_omero.grid.monitors.FileType = FileType
    del FileType

if not _M_omero.grid.monitors.__dict__.has_key('PathMode'):
    _M_omero.grid.monitors.PathMode = Ice.createTempClass()
    class PathMode(object):
        '''Enumeration for Monitor path modes.

Flat, monitor the specified directory but not its subdirectories.
Recursive, monitor the specified directory and its subdirectories.
Follow,  monitor as Recursive but with new directories being added
to the monitor if they are created.

Not all path modes may be implemented for a given operating system.'''

        def __init__(self, val):
            assert(val >= 0 and val < 3)
            self.value = val

        def __str__(self):
            return self._names[self.value]

        __repr__ = __str__

        def __hash__(self):
            return self.value

        def __lt__(self, other):
            if isinstance(other, _M_omero.grid.monitors.PathMode):
                return self.value < other.value;
            elif other == None:
                return False
            return NotImplemented

        def __le__(self, other):
            if isinstance(other, _M_omero.grid.monitors.PathMode):
                return self.value <= other.value;
            elif other == None:
                return False
            return NotImplemented

        def __eq__(self, other):
            if isinstance(other, _M_omero.grid.monitors.PathMode):
                return self.value == other.value;
            elif other == None:
                return False
            return NotImplemented

        def __ne__(self, other):
            if isinstance(other, _M_omero.grid.monitors.PathMode):
                return self.value != other.value;
            elif other == None:
                return False
            return NotImplemented

        def __gt__(self, other):
            if isinstance(other, _M_omero.grid.monitors.PathMode):
                return self.value > other.value;
            elif other == None:
                return False
            return NotImplemented

        def __ge__(self, other):
            if isinstance(other, _M_omero.grid.monitors.PathMode):
                return self.value >= other.value;
            elif other == None:
                return False
            return NotImplemented

        _names = ('Flat', 'Recurse', 'Follow')

    PathMode.Flat = PathMode(0)
    PathMode.Recurse = PathMode(1)
    PathMode.Follow = PathMode(2)

    _M_omero.grid.monitors._t_PathMode = IcePy.defineEnum('::omero::grid::monitors::PathMode', PathMode, (), (PathMode.Flat, PathMode.Recurse, PathMode.Follow))

    _M_omero.grid.monitors.PathMode = PathMode
    del PathMode

if not _M_omero.grid.monitors.__dict__.has_key('WatchEventType'):
    _M_omero.grid.monitors.WatchEventType = Ice.createTempClass()
    class WatchEventType(object):
        '''Enumeration for event types to watch.

Create, notify on file creation only.
Modify, notify on file modification only.
Delete, notify on file deletion only.
All, notify on all vents in the enumeration that apply to a given OS.

Not all event types may be implemented for a given operating system.'''

        def __init__(self, val):
            assert(val >= 0 and val < 4)
            self.value = val

        def __str__(self):
            return self._names[self.value]

        __repr__ = __str__

        def __hash__(self):
            return self.value

        def __lt__(self, other):
            if isinstance(other, _M_omero.grid.monitors.WatchEventType):
                return self.value < other.value;
            elif other == None:
                return False
            return NotImplemented

        def __le__(self, other):
            if isinstance(other, _M_omero.grid.monitors.WatchEventType):
                return self.value <= other.value;
            elif other == None:
                return False
            return NotImplemented

        def __eq__(self, other):
            if isinstance(other, _M_omero.grid.monitors.WatchEventType):
                return self.value == other.value;
            elif other == None:
                return False
            return NotImplemented

        def __ne__(self, other):
            if isinstance(other, _M_omero.grid.monitors.WatchEventType):
                return self.value != other.value;
            elif other == None:
                return False
            return NotImplemented

        def __gt__(self, other):
            if isinstance(other, _M_omero.grid.monitors.WatchEventType):
                return self.value > other.value;
            elif other == None:
                return False
            return NotImplemented

        def __ge__(self, other):
            if isinstance(other, _M_omero.grid.monitors.WatchEventType):
                return self.value >= other.value;
            elif other == None:
                return False
            return NotImplemented

        _names = ('Creation', 'Modification', 'Deletion', 'All')

    WatchEventType.Creation = WatchEventType(0)
    WatchEventType.Modification = WatchEventType(1)
    WatchEventType.Deletion = WatchEventType(2)
    WatchEventType.All = WatchEventType(3)

    _M_omero.grid.monitors._t_WatchEventType = IcePy.defineEnum('::omero::grid::monitors::WatchEventType', WatchEventType, (), (WatchEventType.Creation, WatchEventType.Modification, WatchEventType.Deletion, WatchEventType.All))

    _M_omero.grid.monitors.WatchEventType = WatchEventType
    del WatchEventType

if not _M_omero.grid.monitors.__dict__.has_key('MonitorState'):
    _M_omero.grid.monitors.MonitorState = Ice.createTempClass()
    class MonitorState(object):
        '''Enumeration for Monitor state.

Stopped, a monitor exists but is not actively monitoring.
Started, a monitor exists and is actively monitoring.'''

        def __init__(self, val):
            assert(val >= 0 and val < 2)
            self.value = val

        def __str__(self):
            return self._names[self.value]

        __repr__ = __str__

        def __hash__(self):
            return self.value

        def __lt__(self, other):
            if isinstance(other, _M_omero.grid.monitors.MonitorState):
                return self.value < other.value;
            elif other == None:
                return False
            return NotImplemented

        def __le__(self, other):
            if isinstance(other, _M_omero.grid.monitors.MonitorState):
                return self.value <= other.value;
            elif other == None:
                return False
            return NotImplemented

        def __eq__(self, other):
            if isinstance(other, _M_omero.grid.monitors.MonitorState):
                return self.value == other.value;
            elif other == None:
                return False
            return NotImplemented

        def __ne__(self, other):
            if isinstance(other, _M_omero.grid.monitors.MonitorState):
                return self.value != other.value;
            elif other == None:
                return False
            return NotImplemented

        def __gt__(self, other):
            if isinstance(other, _M_omero.grid.monitors.MonitorState):
                return self.value > other.value;
            elif other == None:
                return False
            return NotImplemented

        def __ge__(self, other):
            if isinstance(other, _M_omero.grid.monitors.MonitorState):
                return self.value >= other.value;
            elif other == None:
                return False
            return NotImplemented

        _names = ('Stopped', 'Started')

    MonitorState.Stopped = MonitorState(0)
    MonitorState.Started = MonitorState(1)

    _M_omero.grid.monitors._t_MonitorState = IcePy.defineEnum('::omero::grid::monitors::MonitorState', MonitorState, (), (MonitorState.Stopped, MonitorState.Started))

    _M_omero.grid.monitors.MonitorState = MonitorState
    del MonitorState

if not _M_omero.grid.monitors.__dict__.has_key('FileStats'):
    _M_omero.grid.monitors.FileStats = Ice.createTempClass()
    class FileStats(object):
        '''File stats.

What stats are likely to be needed? Could this struct be trimmed down
or does it need any further attributes?'''
        def __init__(self, baseName='', owner='', size=0, mTime=0.0, cTime=0.0, aTime=0.0, type=_M_omero.grid.monitors.FileType.File):
            self.baseName = baseName
            self.owner = owner
            self.size = size
            self.mTime = mTime
            self.cTime = cTime
            self.aTime = aTime
            self.type = type

        def __hash__(self):
            _h = 0
            _h = 5 * _h + __builtin__.hash(self.baseName)
            _h = 5 * _h + __builtin__.hash(self.owner)
            _h = 5 * _h + __builtin__.hash(self.size)
            _h = 5 * _h + __builtin__.hash(self.mTime)
            _h = 5 * _h + __builtin__.hash(self.cTime)
            _h = 5 * _h + __builtin__.hash(self.aTime)
            _h = 5 * _h + __builtin__.hash(self.type)
            return _h % 0x7fffffff

        def __lt__(self, other):
            if isinstance(other, _M_omero.grid.monitors.FileStats):
                return self.baseName < other.baseName or self.owner < other.owner or self.size < other.size or self.mTime < other.mTime or self.cTime < other.cTime or self.aTime < other.aTime or self.type < other.type
            elif other == None:
                return False
            return NotImplemented

        def __le__(self, other):
            if isinstance(other, _M_omero.grid.monitors.FileStats):
                return self.baseName <= other.baseName or self.owner <= other.owner or self.size <= other.size or self.mTime <= other.mTime or self.cTime <= other.cTime or self.aTime <= other.aTime or self.type <= other.type
            elif other == None:
                return False
            return NotImplemented

        def __eq__(self, other):
            if isinstance(other, _M_omero.grid.monitors.FileStats):
                return self.baseName == other.baseName and self.owner == other.owner and self.size == other.size and self.mTime == other.mTime and self.cTime == other.cTime and self.aTime == other.aTime and self.type == other.type
            elif other == None:
                return False
            return NotImplemented

        def __ne__(self, other):
            if isinstance(other, _M_omero.grid.monitors.FileStats):
                return self.baseName != other.baseName or self.owner != other.owner or self.size != other.size or self.mTime != other.mTime or self.cTime != other.cTime or self.aTime != other.aTime or self.type != other.type
            elif other == None:
                return True
            return NotImplemented

        def __gt__(self, other):
            if isinstance(other, _M_omero.grid.monitors.FileStats):
                return self.baseName > other.baseName or self.owner > other.owner or self.size > other.size or self.mTime > other.mTime or self.cTime > other.cTime or self.aTime > other.aTime or self.type > other.type
            elif other == None:
                return False
            return NotImplemented

        def __ge__(self, other):
            if isinstance(other, _M_omero.grid.monitors.FileStats):
                return self.baseName >= other.baseName or self.owner >= other.owner or self.size >= other.size or self.mTime >= other.mTime or self.cTime >= other.cTime or self.aTime >= other.aTime or self.type >= other.type
            elif other == None:
                return False
            return NotImplemented

        def __str__(self):
            return IcePy.stringify(self, _M_omero.grid.monitors._t_FileStats)

        __repr__ = __str__

    _M_omero.grid.monitors._t_FileStats = IcePy.defineStruct('::omero::grid::monitors::FileStats', FileStats, (), (
        ('baseName', (), IcePy._t_string),
        ('owner', (), IcePy._t_string),
        ('size', (), IcePy._t_long),
        ('mTime', (), IcePy._t_float),
        ('cTime', (), IcePy._t_float),
        ('aTime', (), IcePy._t_float),
        ('type', (), _M_omero.grid.monitors._t_FileType)
    ))

    _M_omero.grid.monitors.FileStats = FileStats
    del FileStats

if not _M_omero.grid.monitors.__dict__.has_key('_t_WatchEventList'):
    _M_omero.grid.monitors._t_WatchEventList = IcePy.defineSequence('::omero::grid::monitors::WatchEventList', (), _M_omero.grid.monitors._t_WatchEventType)

if not _M_omero.grid.monitors.__dict__.has_key('_t_FileStatsList'):
    _M_omero.grid.monitors._t_FileStatsList = IcePy.defineSequence('::omero::grid::monitors::FileStatsList', (), _M_omero.grid.monitors._t_FileStats)

if not _M_omero.grid.monitors.__dict__.has_key('FileServer'):
    _M_omero.grid.monitors.FileServer = Ice.createTempClass()
    class FileServer(Ice.Object):
        def __init__(self):
            if __builtin__.type(self) == _M_omero.grid.monitors.FileServer:
                raise RuntimeError('omero.grid.monitors.FileServer is an abstract class')

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::omero::grid::monitors::FileServer')

        def ice_id(self, current=None):
            return '::omero::grid::monitors::FileServer'

        def ice_staticId():
            return '::omero::grid::monitors::FileServer'
        ice_staticId = staticmethod(ice_staticId)

        def getDirectory(self, absPath, filter, current=None):
            '''Get an absolute directory from an OMERO.fs server.

The returned list will contain just the file names for each directory entry.

An exception will be raised if the path does not exist or is inaccessible to the
OMERO.fs server. An exception will be raised if directory list cannot be
returned for any other reason.

Arguments:
    absPath, an absolute path on the monitor's watch path (string).
    filter, a filter to apply to the listing, cf. ls (string).
Returns:
     a directory listing (Ice::StringSeq).
Exceptions:
    omero::OmeroFSError'''
            pass

        def getBulkDirectory(self, absPath, filter, current=None):
            '''Get an absolute directory from an OMERO.fs server. 

The returned list will contain the file stats for each directory entry.

An exception will be raised if the path does not exist or is inaccessible to the
OMERO.fs server. An exception will be raised if directory list cannot be
returned for any other reason.

Arguments:
    absPath, an absolute path on the monitor's watch path (string).
    filter, a filter to apply to the listing, cf. ls (string).
Returns:
     a directory listing (FileStatsList).
Exceptions:
    omero::OmeroFSError'''
            pass

        def fileExists(self, fileId, current=None):
            '''Query the existence of a file

An exception will be raised if the method fails to determine the existence.

Arguments:
    fileId, see above.
Returns:
    existence of file.
Exceptions:
    omero::OmeroFSError'''
            pass

        def getBaseName(self, fileId, current=None):
            '''Get base name of a file, this is the name
stripped of any path, e.g. file.ext

An exception will be raised if the file no longer exists or is inaccessible.

Arguments:
    fileId, see above.
Returns:
    base name.
Exceptions:
    omero::OmeroFSError'''
            pass

        def getStats(self, fileId, current=None):
            '''Get all FileStats of a file

An exception will be raised if the file no longer exists or is inaccessible.

Arguments:
    fileId, see above.
Returns:
    file stats (FileStats).
Exceptions:
    omero::OmeroFSError'''
            pass

        def getSize(self, fileId, current=None):
            '''Get size of a file in bytes

An exception will be raised if the file no longer exists or is inaccessible.

Arguments:
    fileId, see above.
Returns:
    byte size of file (long).
Exceptions:
    omero::OmeroFSError'''
            pass

        def getOwner(self, fileId, current=None):
            '''Get owner of a file

An exception will be raised if the file no longer exists or is inaccessible.

Arguments:
    fileId, see above.
Returns:
    owner of file (string).
Exceptions:
    omero::OmeroFSError'''
            pass

        def getCTime(self, fileId, current=None):
            '''Get ctime of a file

An exception will be raised if the file no longer exists or is inaccessible.

Arguments:
    fileId, see above.
Returns:
    ctime of file (float).
Exceptions:
    omero::OmeroFSError'''
            pass

        def getMTime(self, fileId, current=None):
            '''Get mtime of a file

An exception will be raised if the file no longer exists or is inaccessible.

Arguments:
    fileId, see above.
Returns:
    mtime of file (float).
Exceptions:
    omero::OmeroFSError'''
            pass

        def getATime(self, fileId, current=None):
            '''Get atime of a file

An exception will be raised if the file no longer exists or is inaccessible.

Arguments:
    fileId, see above.
Returns:
    atime of file (float).
Exceptions:
    omero::OmeroFSError'''
            pass

        def isDir(self, fileId, current=None):
            '''Query whether file is a directory

An exception will be raised if the file no longer exists or is inaccessible.

Arguments:
    fileId, see above.
Returns:
    true is directory (bool).
Exceptions:
    omero::OmeroFSError'''
            pass

        def isFile(self, fileId, current=None):
            '''Query whether file is a file

An exception will be raised if the file no longer exists or is inaccessible.

Arguments:
    fileId, see above.
Returns:
    true if file (bool).
Exceptions:
    omero::OmeroFSError'''
            pass

        def getSHA1(self, fileId, current=None):
            '''Get SHA1 of a file

An exception will be raised if the file no longer exists or is inaccessible.
An exception will be raised if the SHA1 cannot be generated for any reason.

Arguments:
    fileId, see above.
Returns:
    SHA1 hex hash digest of file (string).
Exceptions:
    omero::OmeroFSError'''
            pass

        def readBlock(self, fileId, offset, size, current=None):
            '''readBlock should open, read size bytes from offset
and then close the file.

An exception will be raised if the file no longer exists or is inaccessible.
An exception will be raised if the file read fails for any other reason.

Arguments:
    fileId, see above.
    offset, byte offset into file from where read should begin (long).
    size, number of bytes that should be read (int).
Returns:
    byte sequence of upto size bytes.
Exceptions:
    omero::OmeroFSError'''
            pass

        def __str__(self):
            return IcePy.stringify(self, _M_omero.grid.monitors._t_FileServer)

        __repr__ = __str__

    _M_omero.grid.monitors.FileServerPrx = Ice.createTempClass()
    class FileServerPrx(Ice.ObjectPrx):

        '''Get an absolute directory from an OMERO.fs server.

The returned list will contain just the file names for each directory entry.

An exception will be raised if the path does not exist or is inaccessible to the
OMERO.fs server. An exception will be raised if directory list cannot be
returned for any other reason.

Arguments:
    absPath, an absolute path on the monitor's watch path (string).
    filter, a filter to apply to the listing, cf. ls (string).
Returns:
     a directory listing (Ice::StringSeq).
Exceptions:
    omero::OmeroFSError'''
        def getDirectory(self, absPath, filter, _ctx=None):
            return _M_omero.grid.monitors.FileServer._op_getDirectory.invoke(self, ((absPath, filter), _ctx))

        '''Get an absolute directory from an OMERO.fs server.

The returned list will contain just the file names for each directory entry.

An exception will be raised if the path does not exist or is inaccessible to the
OMERO.fs server. An exception will be raised if directory list cannot be
returned for any other reason.

Arguments:
    absPath, an absolute path on the monitor's watch path (string).
    filter, a filter to apply to the listing, cf. ls (string).
Returns:
     a directory listing (Ice::StringSeq).
Exceptions:
    omero::OmeroFSError'''
        def begin_getDirectory(self, absPath, filter, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_omero.grid.monitors.FileServer._op_getDirectory.begin(self, ((absPath, filter), _response, _ex, _sent, _ctx))

        '''Get an absolute directory from an OMERO.fs server.

The returned list will contain just the file names for each directory entry.

An exception will be raised if the path does not exist or is inaccessible to the
OMERO.fs server. An exception will be raised if directory list cannot be
returned for any other reason.

Arguments:
    absPath, an absolute path on the monitor's watch path (string).
    filter, a filter to apply to the listing, cf. ls (string).
Returns:
     a directory listing (Ice::StringSeq).
Exceptions:
    omero::OmeroFSError'''
        def end_getDirectory(self, _r):
            return _M_omero.grid.monitors.FileServer._op_getDirectory.end(self, _r)

        '''Get an absolute directory from an OMERO.fs server. 

The returned list will contain the file stats for each directory entry.

An exception will be raised if the path does not exist or is inaccessible to the
OMERO.fs server. An exception will be raised if directory list cannot be
returned for any other reason.

Arguments:
    absPath, an absolute path on the monitor's watch path (string).
    filter, a filter to apply to the listing, cf. ls (string).
Returns:
     a directory listing (FileStatsList).
Exceptions:
    omero::OmeroFSError'''
        def getBulkDirectory(self, absPath, filter, _ctx=None):
            return _M_omero.grid.monitors.FileServer._op_getBulkDirectory.invoke(self, ((absPath, filter), _ctx))

        '''Get an absolute directory from an OMERO.fs server. 

The returned list will contain the file stats for each directory entry.

An exception will be raised if the path does not exist or is inaccessible to the
OMERO.fs server. An exception will be raised if directory list cannot be
returned for any other reason.

Arguments:
    absPath, an absolute path on the monitor's watch path (string).
    filter, a filter to apply to the listing, cf. ls (string).
Returns:
     a directory listing (FileStatsList).
Exceptions:
    omero::OmeroFSError'''
        def begin_getBulkDirectory(self, absPath, filter, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_omero.grid.monitors.FileServer._op_getBulkDirectory.begin(self, ((absPath, filter), _response, _ex, _sent, _ctx))

        '''Get an absolute directory from an OMERO.fs server. 

The returned list will contain the file stats for each directory entry.

An exception will be raised if the path does not exist or is inaccessible to the
OMERO.fs server. An exception will be raised if directory list cannot be
returned for any other reason.

Arguments:
    absPath, an absolute path on the monitor's watch path (string).
    filter, a filter to apply to the listing, cf. ls (string).
Returns:
     a directory listing (FileStatsList).
Exceptions:
    omero::OmeroFSError'''
        def end_getBulkDirectory(self, _r):
            return _M_omero.grid.monitors.FileServer._op_getBulkDirectory.end(self, _r)

        '''Query the existence of a file

An exception will be raised if the method fails to determine the existence.

Arguments:
    fileId, see above.
Returns:
    existence of file.
Exceptions:
    omero::OmeroFSError'''
        def fileExists(self, fileId, _ctx=None):
            return _M_omero.grid.monitors.FileServer._op_fileExists.invoke(self, ((fileId, ), _ctx))

        '''Query the existence of a file

An exception will be raised if the method fails to determine the existence.

Arguments:
    fileId, see above.
Returns:
    existence of file.
Exceptions:
    omero::OmeroFSError'''
        def begin_fileExists(self, fileId, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_omero.grid.monitors.FileServer._op_fileExists.begin(self, ((fileId, ), _response, _ex, _sent, _ctx))

        '''Query the existence of a file

An exception will be raised if the method fails to determine the existence.

Arguments:
    fileId, see above.
Returns:
    existence of file.
Exceptions:
    omero::OmeroFSError'''
        def end_fileExists(self, _r):
            return _M_omero.grid.monitors.FileServer._op_fileExists.end(self, _r)

        '''Get base name of a file, this is the name
stripped of any path, e.g. file.ext

An exception will be raised if the file no longer exists or is inaccessible.

Arguments:
    fileId, see above.
Returns:
    base name.
Exceptions:
    omero::OmeroFSError'''
        def getBaseName(self, fileId, _ctx=None):
            return _M_omero.grid.monitors.FileServer._op_getBaseName.invoke(self, ((fileId, ), _ctx))

        '''Get base name of a file, this is the name
stripped of any path, e.g. file.ext

An exception will be raised if the file no longer exists or is inaccessible.

Arguments:
    fileId, see above.
Returns:
    base name.
Exceptions:
    omero::OmeroFSError'''
        def begin_getBaseName(self, fileId, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_omero.grid.monitors.FileServer._op_getBaseName.begin(self, ((fileId, ), _response, _ex, _sent, _ctx))

        '''Get base name of a file, this is the name
stripped of any path, e.g. file.ext

An exception will be raised if the file no longer exists or is inaccessible.

Arguments:
    fileId, see above.
Returns:
    base name.
Exceptions:
    omero::OmeroFSError'''
        def end_getBaseName(self, _r):
            return _M_omero.grid.monitors.FileServer._op_getBaseName.end(self, _r)

        '''Get all FileStats of a file

An exception will be raised if the file no longer exists or is inaccessible.

Arguments:
    fileId, see above.
Returns:
    file stats (FileStats).
Exceptions:
    omero::OmeroFSError'''
        def getStats(self, fileId, _ctx=None):
            return _M_omero.grid.monitors.FileServer._op_getStats.invoke(self, ((fileId, ), _ctx))

        '''Get all FileStats of a file

An exception will be raised if the file no longer exists or is inaccessible.

Arguments:
    fileId, see above.
Returns:
    file stats (FileStats).
Exceptions:
    omero::OmeroFSError'''
        def begin_getStats(self, fileId, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_omero.grid.monitors.FileServer._op_getStats.begin(self, ((fileId, ), _response, _ex, _sent, _ctx))

        '''Get all FileStats of a file

An exception will be raised if the file no longer exists or is inaccessible.

Arguments:
    fileId, see above.
Returns:
    file stats (FileStats).
Exceptions:
    omero::OmeroFSError'''
        def end_getStats(self, _r):
            return _M_omero.grid.monitors.FileServer._op_getStats.end(self, _r)

        '''Get size of a file in bytes

An exception will be raised if the file no longer exists or is inaccessible.

Arguments:
    fileId, see above.
Returns:
    byte size of file (long).
Exceptions:
    omero::OmeroFSError'''
        def getSize(self, fileId, _ctx=None):
            return _M_omero.grid.monitors.FileServer._op_getSize.invoke(self, ((fileId, ), _ctx))

        '''Get size of a file in bytes

An exception will be raised if the file no longer exists or is inaccessible.

Arguments:
    fileId, see above.
Returns:
    byte size of file (long).
Exceptions:
    omero::OmeroFSError'''
        def begin_getSize(self, fileId, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_omero.grid.monitors.FileServer._op_getSize.begin(self, ((fileId, ), _response, _ex, _sent, _ctx))

        '''Get size of a file in bytes

An exception will be raised if the file no longer exists or is inaccessible.

Arguments:
    fileId, see above.
Returns:
    byte size of file (long).
Exceptions:
    omero::OmeroFSError'''
        def end_getSize(self, _r):
            return _M_omero.grid.monitors.FileServer._op_getSize.end(self, _r)

        '''Get owner of a file

An exception will be raised if the file no longer exists or is inaccessible.

Arguments:
    fileId, see above.
Returns:
    owner of file (string).
Exceptions:
    omero::OmeroFSError'''
        def getOwner(self, fileId, _ctx=None):
            return _M_omero.grid.monitors.FileServer._op_getOwner.invoke(self, ((fileId, ), _ctx))

        '''Get owner of a file

An exception will be raised if the file no longer exists or is inaccessible.

Arguments:
    fileId, see above.
Returns:
    owner of file (string).
Exceptions:
    omero::OmeroFSError'''
        def begin_getOwner(self, fileId, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_omero.grid.monitors.FileServer._op_getOwner.begin(self, ((fileId, ), _response, _ex, _sent, _ctx))

        '''Get owner of a file

An exception will be raised if the file no longer exists or is inaccessible.

Arguments:
    fileId, see above.
Returns:
    owner of file (string).
Exceptions:
    omero::OmeroFSError'''
        def end_getOwner(self, _r):
            return _M_omero.grid.monitors.FileServer._op_getOwner.end(self, _r)

        '''Get ctime of a file

An exception will be raised if the file no longer exists or is inaccessible.

Arguments:
    fileId, see above.
Returns:
    ctime of file (float).
Exceptions:
    omero::OmeroFSError'''
        def getCTime(self, fileId, _ctx=None):
            return _M_omero.grid.monitors.FileServer._op_getCTime.invoke(self, ((fileId, ), _ctx))

        '''Get ctime of a file

An exception will be raised if the file no longer exists or is inaccessible.

Arguments:
    fileId, see above.
Returns:
    ctime of file (float).
Exceptions:
    omero::OmeroFSError'''
        def begin_getCTime(self, fileId, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_omero.grid.monitors.FileServer._op_getCTime.begin(self, ((fileId, ), _response, _ex, _sent, _ctx))

        '''Get ctime of a file

An exception will be raised if the file no longer exists or is inaccessible.

Arguments:
    fileId, see above.
Returns:
    ctime of file (float).
Exceptions:
    omero::OmeroFSError'''
        def end_getCTime(self, _r):
            return _M_omero.grid.monitors.FileServer._op_getCTime.end(self, _r)

        '''Get mtime of a file

An exception will be raised if the file no longer exists or is inaccessible.

Arguments:
    fileId, see above.
Returns:
    mtime of file (float).
Exceptions:
    omero::OmeroFSError'''
        def getMTime(self, fileId, _ctx=None):
            return _M_omero.grid.monitors.FileServer._op_getMTime.invoke(self, ((fileId, ), _ctx))

        '''Get mtime of a file

An exception will be raised if the file no longer exists or is inaccessible.

Arguments:
    fileId, see above.
Returns:
    mtime of file (float).
Exceptions:
    omero::OmeroFSError'''
        def begin_getMTime(self, fileId, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_omero.grid.monitors.FileServer._op_getMTime.begin(self, ((fileId, ), _response, _ex, _sent, _ctx))

        '''Get mtime of a file

An exception will be raised if the file no longer exists or is inaccessible.

Arguments:
    fileId, see above.
Returns:
    mtime of file (float).
Exceptions:
    omero::OmeroFSError'''
        def end_getMTime(self, _r):
            return _M_omero.grid.monitors.FileServer._op_getMTime.end(self, _r)

        '''Get atime of a file

An exception will be raised if the file no longer exists or is inaccessible.

Arguments:
    fileId, see above.
Returns:
    atime of file (float).
Exceptions:
    omero::OmeroFSError'''
        def getATime(self, fileId, _ctx=None):
            return _M_omero.grid.monitors.FileServer._op_getATime.invoke(self, ((fileId, ), _ctx))

        '''Get atime of a file

An exception will be raised if the file no longer exists or is inaccessible.

Arguments:
    fileId, see above.
Returns:
    atime of file (float).
Exceptions:
    omero::OmeroFSError'''
        def begin_getATime(self, fileId, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_omero.grid.monitors.FileServer._op_getATime.begin(self, ((fileId, ), _response, _ex, _sent, _ctx))

        '''Get atime of a file

An exception will be raised if the file no longer exists or is inaccessible.

Arguments:
    fileId, see above.
Returns:
    atime of file (float).
Exceptions:
    omero::OmeroFSError'''
        def end_getATime(self, _r):
            return _M_omero.grid.monitors.FileServer._op_getATime.end(self, _r)

        '''Query whether file is a directory

An exception will be raised if the file no longer exists or is inaccessible.

Arguments:
    fileId, see above.
Returns:
    true is directory (bool).
Exceptions:
    omero::OmeroFSError'''
        def isDir(self, fileId, _ctx=None):
            return _M_omero.grid.monitors.FileServer._op_isDir.invoke(self, ((fileId, ), _ctx))

        '''Query whether file is a directory

An exception will be raised if the file no longer exists or is inaccessible.

Arguments:
    fileId, see above.
Returns:
    true is directory (bool).
Exceptions:
    omero::OmeroFSError'''
        def begin_isDir(self, fileId, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_omero.grid.monitors.FileServer._op_isDir.begin(self, ((fileId, ), _response, _ex, _sent, _ctx))

        '''Query whether file is a directory

An exception will be raised if the file no longer exists or is inaccessible.

Arguments:
    fileId, see above.
Returns:
    true is directory (bool).
Exceptions:
    omero::OmeroFSError'''
        def end_isDir(self, _r):
            return _M_omero.grid.monitors.FileServer._op_isDir.end(self, _r)

        '''Query whether file is a file

An exception will be raised if the file no longer exists or is inaccessible.

Arguments:
    fileId, see above.
Returns:
    true if file (bool).
Exceptions:
    omero::OmeroFSError'''
        def isFile(self, fileId, _ctx=None):
            return _M_omero.grid.monitors.FileServer._op_isFile.invoke(self, ((fileId, ), _ctx))

        '''Query whether file is a file

An exception will be raised if the file no longer exists or is inaccessible.

Arguments:
    fileId, see above.
Returns:
    true if file (bool).
Exceptions:
    omero::OmeroFSError'''
        def begin_isFile(self, fileId, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_omero.grid.monitors.FileServer._op_isFile.begin(self, ((fileId, ), _response, _ex, _sent, _ctx))

        '''Query whether file is a file

An exception will be raised if the file no longer exists or is inaccessible.

Arguments:
    fileId, see above.
Returns:
    true if file (bool).
Exceptions:
    omero::OmeroFSError'''
        def end_isFile(self, _r):
            return _M_omero.grid.monitors.FileServer._op_isFile.end(self, _r)

        '''Get SHA1 of a file

An exception will be raised if the file no longer exists or is inaccessible.
An exception will be raised if the SHA1 cannot be generated for any reason.

Arguments:
    fileId, see above.
Returns:
    SHA1 hex hash digest of file (string).
Exceptions:
    omero::OmeroFSError'''
        def getSHA1(self, fileId, _ctx=None):
            return _M_omero.grid.monitors.FileServer._op_getSHA1.invoke(self, ((fileId, ), _ctx))

        '''Get SHA1 of a file

An exception will be raised if the file no longer exists or is inaccessible.
An exception will be raised if the SHA1 cannot be generated for any reason.

Arguments:
    fileId, see above.
Returns:
    SHA1 hex hash digest of file (string).
Exceptions:
    omero::OmeroFSError'''
        def begin_getSHA1(self, fileId, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_omero.grid.monitors.FileServer._op_getSHA1.begin(self, ((fileId, ), _response, _ex, _sent, _ctx))

        '''Get SHA1 of a file

An exception will be raised if the file no longer exists or is inaccessible.
An exception will be raised if the SHA1 cannot be generated for any reason.

Arguments:
    fileId, see above.
Returns:
    SHA1 hex hash digest of file (string).
Exceptions:
    omero::OmeroFSError'''
        def end_getSHA1(self, _r):
            return _M_omero.grid.monitors.FileServer._op_getSHA1.end(self, _r)

        '''readBlock should open, read size bytes from offset
and then close the file.

An exception will be raised if the file no longer exists or is inaccessible.
An exception will be raised if the file read fails for any other reason.

Arguments:
    fileId, see above.
    offset, byte offset into file from where read should begin (long).
    size, number of bytes that should be read (int).
Returns:
    byte sequence of upto size bytes.
Exceptions:
    omero::OmeroFSError'''
        def readBlock(self, fileId, offset, size, _ctx=None):
            return _M_omero.grid.monitors.FileServer._op_readBlock.invoke(self, ((fileId, offset, size), _ctx))

        '''readBlock should open, read size bytes from offset
and then close the file.

An exception will be raised if the file no longer exists or is inaccessible.
An exception will be raised if the file read fails for any other reason.

Arguments:
    fileId, see above.
    offset, byte offset into file from where read should begin (long).
    size, number of bytes that should be read (int).
Returns:
    byte sequence of upto size bytes.
Exceptions:
    omero::OmeroFSError'''
        def begin_readBlock(self, fileId, offset, size, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_omero.grid.monitors.FileServer._op_readBlock.begin(self, ((fileId, offset, size), _response, _ex, _sent, _ctx))

        '''readBlock should open, read size bytes from offset
and then close the file.

An exception will be raised if the file no longer exists or is inaccessible.
An exception will be raised if the file read fails for any other reason.

Arguments:
    fileId, see above.
    offset, byte offset into file from where read should begin (long).
    size, number of bytes that should be read (int).
Returns:
    byte sequence of upto size bytes.
Exceptions:
    omero::OmeroFSError'''
        def end_readBlock(self, _r):
            return _M_omero.grid.monitors.FileServer._op_readBlock.end(self, _r)

        def checkedCast(proxy, facetOrCtx=None, _ctx=None):
            return _M_omero.grid.monitors.FileServerPrx.ice_checkedCast(proxy, '::omero::grid::monitors::FileServer', facetOrCtx, _ctx)
        checkedCast = staticmethod(checkedCast)

        def uncheckedCast(proxy, facet=None):
            return _M_omero.grid.monitors.FileServerPrx.ice_uncheckedCast(proxy, facet)
        uncheckedCast = staticmethod(uncheckedCast)

    _M_omero.grid.monitors._t_FileServerPrx = IcePy.defineProxy('::omero::grid::monitors::FileServer', FileServerPrx)

    _M_omero.grid.monitors._t_FileServer = IcePy.defineClass('::omero::grid::monitors::FileServer', FileServer, (), True, None, (), ())
    FileServer._ice_type = _M_omero.grid.monitors._t_FileServer

    FileServer._op_getDirectory = IcePy.Operation('getDirectory', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, (), (((), IcePy._t_string), ((), IcePy._t_string)), (), _M_Ice._t_StringSeq, (_M_omero._t_OmeroFSError,))
    FileServer._op_getBulkDirectory = IcePy.Operation('getBulkDirectory', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, (), (((), IcePy._t_string), ((), IcePy._t_string)), (), _M_omero.grid.monitors._t_FileStatsList, (_M_omero._t_OmeroFSError,))
    FileServer._op_fileExists = IcePy.Operation('fileExists', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, (), (((), IcePy._t_string),), (), IcePy._t_bool, (_M_omero._t_OmeroFSError,))
    FileServer._op_getBaseName = IcePy.Operation('getBaseName', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, (), (((), IcePy._t_string),), (), IcePy._t_string, (_M_omero._t_OmeroFSError,))
    FileServer._op_getStats = IcePy.Operation('getStats', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, (), (((), IcePy._t_string),), (), _M_omero.grid.monitors._t_FileStats, (_M_omero._t_OmeroFSError,))
    FileServer._op_getSize = IcePy.Operation('getSize', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, (), (((), IcePy._t_string),), (), IcePy._t_long, (_M_omero._t_OmeroFSError,))
    FileServer._op_getOwner = IcePy.Operation('getOwner', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, (), (((), IcePy._t_string),), (), IcePy._t_string, (_M_omero._t_OmeroFSError,))
    FileServer._op_getCTime = IcePy.Operation('getCTime', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, (), (((), IcePy._t_string),), (), IcePy._t_float, (_M_omero._t_OmeroFSError,))
    FileServer._op_getMTime = IcePy.Operation('getMTime', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, (), (((), IcePy._t_string),), (), IcePy._t_float, (_M_omero._t_OmeroFSError,))
    FileServer._op_getATime = IcePy.Operation('getATime', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, (), (((), IcePy._t_string),), (), IcePy._t_float, (_M_omero._t_OmeroFSError,))
    FileServer._op_isDir = IcePy.Operation('isDir', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, (), (((), IcePy._t_string),), (), IcePy._t_bool, (_M_omero._t_OmeroFSError,))
    FileServer._op_isFile = IcePy.Operation('isFile', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, (), (((), IcePy._t_string),), (), IcePy._t_bool, (_M_omero._t_OmeroFSError,))
    FileServer._op_getSHA1 = IcePy.Operation('getSHA1', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, (), (((), IcePy._t_string),), (), IcePy._t_string, (_M_omero._t_OmeroFSError,))
    FileServer._op_readBlock = IcePy.Operation('readBlock', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, (), (((), IcePy._t_string), ((), IcePy._t_long), ((), IcePy._t_int)), (), _M_Ice._t_ByteSeq, (_M_omero._t_OmeroFSError,))

    _M_omero.grid.monitors.FileServer = FileServer
    del FileServer

    _M_omero.grid.monitors.FileServerPrx = FileServerPrx
    del FileServerPrx

if not _M_omero.grid.monitors.__dict__.has_key('MonitorServer'):
    _M_omero.grid.monitors.MonitorServer = Ice.createTempClass()
    class MonitorServer(Ice.Object):
        def __init__(self):
            if __builtin__.type(self) == _M_omero.grid.monitors.MonitorServer:
                raise RuntimeError('omero.grid.monitors.MonitorServer is an abstract class')

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::omero::grid::monitors::MonitorServer')

        def ice_id(self, current=None):
            return '::omero::grid::monitors::MonitorServer'

        def ice_staticId():
            return '::omero::grid::monitors::MonitorServer'
        ice_staticId = staticmethod(ice_staticId)

        def createMonitor(self, mType, eTypes, pMode, pathString, whitelist, blacklist, timeout, blockSize, ignoreSysFiles, ignoreDirEvents, proxy, current=None):
            '''Create a monitor of events.

A exception will be raised if the event type or path mode is not supported by
the Monitor implementation for a given OS. An exception will be raised if the
path does not exist or is inaccessible to the monitor. An exception will be raised
if a monitor cannot be created for any other reason.

Arguments:
    mType, type of monitor to create (MonitorType).
    eTypes, a sequence of watch event type to monitor (WatchEventTypeList).
    pathString, full path of directory of interest (string).
    whitelist, list of files or extensions of interest (Ice::StringSeq).
    blacklist, list of directories, files or extensions that are not of interest (Ice::StringSeq).
    pMode, path mode of monitor (PathMode).
    proxy, a proxy of the client to which notifications will be sent (MonitorClient*).
    timeout, time in seconds fo monitor to time out (float).
    blockSize, the number of events to pack into each notification (int).
    ignoreSysFiles, ignore system files or not (bool).
    ignoreDirEvents, ignore directory events (bool).
Returns:
    monitorId, a uuid1 (string).
Exceptions:
    omero::OmeroFSError'''
            pass

        def startMonitor(self, id, current=None):
            '''Start an existing monitor.

An exception will be raised if the id does not correspond to an existing monitor.
An exception will be raised if a monitor cannot be started for any other reason,
in this case the monitor's state cannot be assumed.

Arguments:
    id, monitor id (string).
Returns:
     no explicit return value.
Exceptions:
    omero::OmeroFSError'''
            pass

        def stopMonitor(self, id, current=None):
            '''Stop an existing monitor.

Attempting to stop a monitor that is not running raises no exception.
An exception will be raised if the id does not correspond to an existing monitor.
An exception will be raised if a monitor cannot be stopped for any other reason,
in this case the monitor's state cannot be assumed.

Arguments:
    id, monitor id (string).
Returns:
     no explicit return value.
Exceptions:
    omero::OmeroFSError'''
            pass

        def destroyMonitor(self, id, current=None):
            '''Destroy an existing monitor.

Attempting to destroy a monitor that is running will try to first stop
the monitor and then destroy it.
An exception will be raised if the id does not correspond to an existing monitor.
An exception will be raised if a monitor cannot be destroyed (or stopped and destroyed)
for any other reason, in this case the monitor's state cannot be assumed.

Arguments:
    id, monitor id (string).
Returns:
     no explicit return value.
Exceptions:
    omero::OmeroFSError'''
            pass

        def getMonitorState(self, id, current=None):
            '''Get the state of an existing monitor.

An exception will be raised if the id does not correspond to an existing monitor.

Arguments:
    id, monitor id (string).
Returns:
     the monitor state (MonitorState).
Exceptions:
    omero::OmeroFSError'''
            pass

        def __str__(self):
            return IcePy.stringify(self, _M_omero.grid.monitors._t_MonitorServer)

        __repr__ = __str__

    _M_omero.grid.monitors.MonitorServerPrx = Ice.createTempClass()
    class MonitorServerPrx(Ice.ObjectPrx):

        '''Create a monitor of events.

A exception will be raised if the event type or path mode is not supported by
the Monitor implementation for a given OS. An exception will be raised if the
path does not exist or is inaccessible to the monitor. An exception will be raised
if a monitor cannot be created for any other reason.

Arguments:
    mType, type of monitor to create (MonitorType).
    eTypes, a sequence of watch event type to monitor (WatchEventTypeList).
    pathString, full path of directory of interest (string).
    whitelist, list of files or extensions of interest (Ice::StringSeq).
    blacklist, list of directories, files or extensions that are not of interest (Ice::StringSeq).
    pMode, path mode of monitor (PathMode).
    proxy, a proxy of the client to which notifications will be sent (MonitorClient*).
    timeout, time in seconds fo monitor to time out (float).
    blockSize, the number of events to pack into each notification (int).
    ignoreSysFiles, ignore system files or not (bool).
    ignoreDirEvents, ignore directory events (bool).
Returns:
    monitorId, a uuid1 (string).
Exceptions:
    omero::OmeroFSError'''
        def createMonitor(self, mType, eTypes, pMode, pathString, whitelist, blacklist, timeout, blockSize, ignoreSysFiles, ignoreDirEvents, proxy, _ctx=None):
            return _M_omero.grid.monitors.MonitorServer._op_createMonitor.invoke(self, ((mType, eTypes, pMode, pathString, whitelist, blacklist, timeout, blockSize, ignoreSysFiles, ignoreDirEvents, proxy), _ctx))

        '''Create a monitor of events.

A exception will be raised if the event type or path mode is not supported by
the Monitor implementation for a given OS. An exception will be raised if the
path does not exist or is inaccessible to the monitor. An exception will be raised
if a monitor cannot be created for any other reason.

Arguments:
    mType, type of monitor to create (MonitorType).
    eTypes, a sequence of watch event type to monitor (WatchEventTypeList).
    pathString, full path of directory of interest (string).
    whitelist, list of files or extensions of interest (Ice::StringSeq).
    blacklist, list of directories, files or extensions that are not of interest (Ice::StringSeq).
    pMode, path mode of monitor (PathMode).
    proxy, a proxy of the client to which notifications will be sent (MonitorClient*).
    timeout, time in seconds fo monitor to time out (float).
    blockSize, the number of events to pack into each notification (int).
    ignoreSysFiles, ignore system files or not (bool).
    ignoreDirEvents, ignore directory events (bool).
Returns:
    monitorId, a uuid1 (string).
Exceptions:
    omero::OmeroFSError'''
        def begin_createMonitor(self, mType, eTypes, pMode, pathString, whitelist, blacklist, timeout, blockSize, ignoreSysFiles, ignoreDirEvents, proxy, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_omero.grid.monitors.MonitorServer._op_createMonitor.begin(self, ((mType, eTypes, pMode, pathString, whitelist, blacklist, timeout, blockSize, ignoreSysFiles, ignoreDirEvents, proxy), _response, _ex, _sent, _ctx))

        '''Create a monitor of events.

A exception will be raised if the event type or path mode is not supported by
the Monitor implementation for a given OS. An exception will be raised if the
path does not exist or is inaccessible to the monitor. An exception will be raised
if a monitor cannot be created for any other reason.

Arguments:
    mType, type of monitor to create (MonitorType).
    eTypes, a sequence of watch event type to monitor (WatchEventTypeList).
    pathString, full path of directory of interest (string).
    whitelist, list of files or extensions of interest (Ice::StringSeq).
    blacklist, list of directories, files or extensions that are not of interest (Ice::StringSeq).
    pMode, path mode of monitor (PathMode).
    proxy, a proxy of the client to which notifications will be sent (MonitorClient*).
    timeout, time in seconds fo monitor to time out (float).
    blockSize, the number of events to pack into each notification (int).
    ignoreSysFiles, ignore system files or not (bool).
    ignoreDirEvents, ignore directory events (bool).
Returns:
    monitorId, a uuid1 (string).
Exceptions:
    omero::OmeroFSError'''
        def end_createMonitor(self, _r):
            return _M_omero.grid.monitors.MonitorServer._op_createMonitor.end(self, _r)

        '''Start an existing monitor.

An exception will be raised if the id does not correspond to an existing monitor.
An exception will be raised if a monitor cannot be started for any other reason,
in this case the monitor's state cannot be assumed.

Arguments:
    id, monitor id (string).
Returns:
     no explicit return value.
Exceptions:
    omero::OmeroFSError'''
        def startMonitor(self, id, _ctx=None):
            return _M_omero.grid.monitors.MonitorServer._op_startMonitor.invoke(self, ((id, ), _ctx))

        '''Start an existing monitor.

An exception will be raised if the id does not correspond to an existing monitor.
An exception will be raised if a monitor cannot be started for any other reason,
in this case the monitor's state cannot be assumed.

Arguments:
    id, monitor id (string).
Returns:
     no explicit return value.
Exceptions:
    omero::OmeroFSError'''
        def begin_startMonitor(self, id, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_omero.grid.monitors.MonitorServer._op_startMonitor.begin(self, ((id, ), _response, _ex, _sent, _ctx))

        '''Start an existing monitor.

An exception will be raised if the id does not correspond to an existing monitor.
An exception will be raised if a monitor cannot be started for any other reason,
in this case the monitor's state cannot be assumed.

Arguments:
    id, monitor id (string).
Returns:
     no explicit return value.
Exceptions:
    omero::OmeroFSError'''
        def end_startMonitor(self, _r):
            return _M_omero.grid.monitors.MonitorServer._op_startMonitor.end(self, _r)

        '''Stop an existing monitor.

Attempting to stop a monitor that is not running raises no exception.
An exception will be raised if the id does not correspond to an existing monitor.
An exception will be raised if a monitor cannot be stopped for any other reason,
in this case the monitor's state cannot be assumed.

Arguments:
    id, monitor id (string).
Returns:
     no explicit return value.
Exceptions:
    omero::OmeroFSError'''
        def stopMonitor(self, id, _ctx=None):
            return _M_omero.grid.monitors.MonitorServer._op_stopMonitor.invoke(self, ((id, ), _ctx))

        '''Stop an existing monitor.

Attempting to stop a monitor that is not running raises no exception.
An exception will be raised if the id does not correspond to an existing monitor.
An exception will be raised if a monitor cannot be stopped for any other reason,
in this case the monitor's state cannot be assumed.

Arguments:
    id, monitor id (string).
Returns:
     no explicit return value.
Exceptions:
    omero::OmeroFSError'''
        def begin_stopMonitor(self, id, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_omero.grid.monitors.MonitorServer._op_stopMonitor.begin(self, ((id, ), _response, _ex, _sent, _ctx))

        '''Stop an existing monitor.

Attempting to stop a monitor that is not running raises no exception.
An exception will be raised if the id does not correspond to an existing monitor.
An exception will be raised if a monitor cannot be stopped for any other reason,
in this case the monitor's state cannot be assumed.

Arguments:
    id, monitor id (string).
Returns:
     no explicit return value.
Exceptions:
    omero::OmeroFSError'''
        def end_stopMonitor(self, _r):
            return _M_omero.grid.monitors.MonitorServer._op_stopMonitor.end(self, _r)

        '''Destroy an existing monitor.

Attempting to destroy a monitor that is running will try to first stop
the monitor and then destroy it.
An exception will be raised if the id does not correspond to an existing monitor.
An exception will be raised if a monitor cannot be destroyed (or stopped and destroyed)
for any other reason, in this case the monitor's state cannot be assumed.

Arguments:
    id, monitor id (string).
Returns:
     no explicit return value.
Exceptions:
    omero::OmeroFSError'''
        def destroyMonitor(self, id, _ctx=None):
            return _M_omero.grid.monitors.MonitorServer._op_destroyMonitor.invoke(self, ((id, ), _ctx))

        '''Destroy an existing monitor.

Attempting to destroy a monitor that is running will try to first stop
the monitor and then destroy it.
An exception will be raised if the id does not correspond to an existing monitor.
An exception will be raised if a monitor cannot be destroyed (or stopped and destroyed)
for any other reason, in this case the monitor's state cannot be assumed.

Arguments:
    id, monitor id (string).
Returns:
     no explicit return value.
Exceptions:
    omero::OmeroFSError'''
        def begin_destroyMonitor(self, id, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_omero.grid.monitors.MonitorServer._op_destroyMonitor.begin(self, ((id, ), _response, _ex, _sent, _ctx))

        '''Destroy an existing monitor.

Attempting to destroy a monitor that is running will try to first stop
the monitor and then destroy it.
An exception will be raised if the id does not correspond to an existing monitor.
An exception will be raised if a monitor cannot be destroyed (or stopped and destroyed)
for any other reason, in this case the monitor's state cannot be assumed.

Arguments:
    id, monitor id (string).
Returns:
     no explicit return value.
Exceptions:
    omero::OmeroFSError'''
        def end_destroyMonitor(self, _r):
            return _M_omero.grid.monitors.MonitorServer._op_destroyMonitor.end(self, _r)

        '''Get the state of an existing monitor.

An exception will be raised if the id does not correspond to an existing monitor.

Arguments:
    id, monitor id (string).
Returns:
     the monitor state (MonitorState).
Exceptions:
    omero::OmeroFSError'''
        def getMonitorState(self, id, _ctx=None):
            return _M_omero.grid.monitors.MonitorServer._op_getMonitorState.invoke(self, ((id, ), _ctx))

        '''Get the state of an existing monitor.

An exception will be raised if the id does not correspond to an existing monitor.

Arguments:
    id, monitor id (string).
Returns:
     the monitor state (MonitorState).
Exceptions:
    omero::OmeroFSError'''
        def begin_getMonitorState(self, id, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_omero.grid.monitors.MonitorServer._op_getMonitorState.begin(self, ((id, ), _response, _ex, _sent, _ctx))

        '''Get the state of an existing monitor.

An exception will be raised if the id does not correspond to an existing monitor.

Arguments:
    id, monitor id (string).
Returns:
     the monitor state (MonitorState).
Exceptions:
    omero::OmeroFSError'''
        def end_getMonitorState(self, _r):
            return _M_omero.grid.monitors.MonitorServer._op_getMonitorState.end(self, _r)

        def checkedCast(proxy, facetOrCtx=None, _ctx=None):
            return _M_omero.grid.monitors.MonitorServerPrx.ice_checkedCast(proxy, '::omero::grid::monitors::MonitorServer', facetOrCtx, _ctx)
        checkedCast = staticmethod(checkedCast)

        def uncheckedCast(proxy, facet=None):
            return _M_omero.grid.monitors.MonitorServerPrx.ice_uncheckedCast(proxy, facet)
        uncheckedCast = staticmethod(uncheckedCast)

    _M_omero.grid.monitors._t_MonitorServerPrx = IcePy.defineProxy('::omero::grid::monitors::MonitorServer', MonitorServerPrx)

    _M_omero.grid.monitors._t_MonitorServer = IcePy.defineClass('::omero::grid::monitors::MonitorServer', MonitorServer, (), True, None, (), ())
    MonitorServer._ice_type = _M_omero.grid.monitors._t_MonitorServer

    MonitorServer._op_createMonitor = IcePy.Operation('createMonitor', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, (), (((), _M_omero.grid.monitors._t_MonitorType), ((), _M_omero.grid.monitors._t_WatchEventList), ((), _M_omero.grid.monitors._t_PathMode), ((), IcePy._t_string), ((), _M_Ice._t_StringSeq), ((), _M_Ice._t_StringSeq), ((), IcePy._t_float), ((), IcePy._t_int), ((), IcePy._t_bool), ((), IcePy._t_bool), ((), _M_omero.grid.monitors._t_MonitorClientPrx)), (), IcePy._t_string, (_M_omero._t_OmeroFSError,))
    MonitorServer._op_startMonitor = IcePy.Operation('startMonitor', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, (), (((), IcePy._t_string),), (), None, (_M_omero._t_OmeroFSError,))
    MonitorServer._op_stopMonitor = IcePy.Operation('stopMonitor', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, (), (((), IcePy._t_string),), (), None, (_M_omero._t_OmeroFSError,))
    MonitorServer._op_destroyMonitor = IcePy.Operation('destroyMonitor', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, (), (((), IcePy._t_string),), (), None, (_M_omero._t_OmeroFSError,))
    MonitorServer._op_getMonitorState = IcePy.Operation('getMonitorState', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, (), (((), IcePy._t_string),), (), _M_omero.grid.monitors._t_MonitorState, (_M_omero._t_OmeroFSError,))

    _M_omero.grid.monitors.MonitorServer = MonitorServer
    del MonitorServer

    _M_omero.grid.monitors.MonitorServerPrx = MonitorServerPrx
    del MonitorServerPrx

# End of module omero.grid.monitors

__name__ = 'omero.grid'

# End of module omero.grid

__name__ = 'omero'

# End of module omero
